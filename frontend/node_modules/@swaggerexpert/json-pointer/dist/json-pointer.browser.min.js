!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.JSONPointer=t():e.JSONPointer=t()}(self,(()=>(()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{ASTTranslator:()=>b,CSTTranslator:()=>x,EvaluationRealm:()=>z,Grammar:()=>h,JSONPointerCompileError:()=>J,JSONPointerError:()=>g,JSONPointerEvaluateError:()=>F,JSONPointerIndexError:()=>G,JSONPointerKeyError:()=>Z,JSONPointerParseError:()=>y,JSONPointerTypeError:()=>X,JSONString:()=>r,URIFragmentIdentifier:()=>n,XMLTranslator:()=>$,compile:()=>V,composeRealms:()=>Q,escape:()=>B,evaluate:()=>W,parse:()=>O,testArrayDash:()=>Y,testArrayIndex:()=>D,testArrayLocation:()=>v,testJSONPointer:()=>M,testReferenceToken:()=>L,unescape:()=>k});var r={};e.r(r),e.d(r,{from:()=>a,to:()=>s});var n={};e.r(n),e.d(n,{from:()=>i,fromURIReference:()=>c,to:()=>o});const s=e=>JSON.stringify(e),a=e=>{try{return String(JSON.parse(e))}catch{return e}},o=e=>`#${[...e].map((e=>/^[A-Za-z0-9\-._~!$&'()*+,;=:@/?]$/.test(e)?e:encodeURIComponent(e))).join("")}`,i=e=>{try{const t=e.startsWith("#")?e.slice(1):e;return decodeURIComponent(t)}catch{return e}},c=e=>{const t=e.indexOf("#"),r=-1===t?"#":e.substring(t);return i(r)};function h(){this.grammarObject="grammarObject",this.rules=[],this.rules[0]={name:"json-pointer",lower:"json-pointer",index:0,isBkr:!1},this.rules[1]={name:"reference-token",lower:"reference-token",index:1,isBkr:!1},this.rules[2]={name:"unescaped",lower:"unescaped",index:2,isBkr:!1},this.rules[3]={name:"escaped",lower:"escaped",index:3,isBkr:!1},this.rules[4]={name:"array-location",lower:"array-location",index:4,isBkr:!1},this.rules[5]={name:"array-index",lower:"array-index",index:5,isBkr:!1},this.rules[6]={name:"array-dash",lower:"array-dash",index:6,isBkr:!1},this.rules[7]={name:"slash",lower:"slash",index:7,isBkr:!1},this.udts=[],this.rules[0].opcodes=[],this.rules[0].opcodes[0]={type:3,min:0,max:1/0},this.rules[0].opcodes[1]={type:2,children:[2,3]},this.rules[0].opcodes[2]={type:4,index:7},this.rules[0].opcodes[3]={type:4,index:1},this.rules[1].opcodes=[],this.rules[1].opcodes[0]={type:3,min:0,max:1/0},this.rules[1].opcodes[1]={type:1,children:[2,3]},this.rules[1].opcodes[2]={type:4,index:2},this.rules[1].opcodes[3]={type:4,index:3},this.rules[2].opcodes=[],this.rules[2].opcodes[0]={type:1,children:[1,2,3]},this.rules[2].opcodes[1]={type:5,min:0,max:46},this.rules[2].opcodes[2]={type:5,min:48,max:125},this.rules[2].opcodes[3]={type:5,min:127,max:1114111},this.rules[3].opcodes=[],this.rules[3].opcodes[0]={type:2,children:[1,2]},this.rules[3].opcodes[1]={type:7,string:[126]},this.rules[3].opcodes[2]={type:1,children:[3,4]},this.rules[3].opcodes[3]={type:7,string:[48]},this.rules[3].opcodes[4]={type:7,string:[49]},this.rules[4].opcodes=[],this.rules[4].opcodes[0]={type:1,children:[1,2]},this.rules[4].opcodes[1]={type:4,index:5},this.rules[4].opcodes[2]={type:4,index:6},this.rules[5].opcodes=[],this.rules[5].opcodes[0]={type:1,children:[1,2]},this.rules[5].opcodes[1]={type:6,string:[48]},this.rules[5].opcodes[2]={type:2,children:[3,4]},this.rules[5].opcodes[3]={type:5,min:49,max:57},this.rules[5].opcodes[4]={type:3,min:0,max:1/0},this.rules[5].opcodes[5]={type:5,min:48,max:57},this.rules[6].opcodes=[],this.rules[6].opcodes[0]={type:7,string:[45]},this.rules[7].opcodes=[],this.rules[7].opcodes[0]={type:7,string:[47]},this.toString=function(){let e="";return e+="; JavaScript Object Notation (JSON) Pointer ABNF syntax\n",e+="; https://datatracker.ietf.org/doc/html/rfc6901\n",e+="json-pointer    = *( slash reference-token ) ; MODIFICATION: surrogate text rule used\n",e+="reference-token = *( unescaped / escaped )\n",e+="unescaped       = %x00-2E / %x30-7D / %x7F-10FFFF\n",e+="                ; %x2F ('/') and %x7E ('~') are excluded from 'unescaped'\n",e+='escaped         = "~" ( "0" / "1" )\n',e+="                ; representing '~' and '/', respectively\n",e+="\n",e+="; https://datatracker.ietf.org/doc/html/rfc6901#section-4\n",e+="array-location  = array-index / array-dash\n",e+="array-index     = %x30 / ( %x31-39 *(%x30-39) )\n",e+='                ; "0", or digits without a leading "0"\n',e+='array-dash      = "-"\n',e+="\n",e+="; Surrogate named rules\n",e+='slash           = "/"\n','; JavaScript Object Notation (JSON) Pointer ABNF syntax\n; https://datatracker.ietf.org/doc/html/rfc6901\njson-pointer    = *( slash reference-token ) ; MODIFICATION: surrogate text rule used\nreference-token = *( unescaped / escaped )\nunescaped       = %x00-2E / %x30-7D / %x7F-10FFFF\n                ; %x2F (\'/\') and %x7E (\'~\') are excluded from \'unescaped\'\nescaped         = "~" ( "0" / "1" )\n                ; representing \'~\' and \'/\', respectively\n\n; https://datatracker.ietf.org/doc/html/rfc6901#section-4\narray-location  = array-index / array-dash\narray-index     = %x30 / ( %x31-39 *(%x30-39) )\n                ; "0", or digits without a leading "0"\narray-dash      = "-"\n\n; Surrogate named rules\nslash           = "/"\n'}}const l=function(){const e=T,t=m,r=this,n="parser.js: Parser(): ";r.ast=void 0,r.stats=void 0,r.trace=void 0,r.callbacks=[];let s,a,o,i,c,h,l,u=0,p=0,d=0,f=0,g=0,y=new function(){this.state=e.ACTIVE,this.phraseLength=0,this.refresh=()=>{this.state=e.ACTIVE,this.phraseLength=0}};r.parse=(m,T,w,x)=>{const b=`${n}parse(): `;u=0,p=0,d=0,f=0,g=0,s=void 0,a=void 0,o=void 0,i=void 0,y.refresh(),c=void 0,h=void 0,l=void 0,i=t.stringToChars(w),s=m.rules,a=m.udts;const A=T.toLowerCase();let E;for(const e in s)if(s.hasOwnProperty(e)&&A===s[e].lower){E=s[e].index;break}if(void 0===E)throw new Error(`${b}start rule name '${startRule}' not recognized`);(()=>{const e=`${n}initializeCallbacks(): `;let t,o;for(c=[],h=[],t=0;t<s.length;t+=1)c[t]=void 0;for(t=0;t<a.length;t+=1)h[t]=void 0;const i=[];for(t=0;t<s.length;t+=1)i.push(s[t].lower);for(t=0;t<a.length;t+=1)i.push(a[t].lower);for(const n in r.callbacks)if(r.callbacks.hasOwnProperty(n)){if(t=i.indexOf(n.toLowerCase()),t<0)throw new Error(`${e}syntax callback '${n}' not a rule or udt name`);if(o=r.callbacks[n]?r.callbacks[n]:void 0,"function"!=typeof o&&void 0!==o)throw new Error(`${e}syntax callback[${n}] must be function reference or falsy)`);t<s.length?c[t]=o:h[t-s.length]=o}})(),r.trace&&r.trace.init(s,a,i),r.stats&&r.stats.init(s,a),r.ast&&r.ast.init(s,a,i),l=x,o=[{type:e.RNM,index:E}],k(0,0),o=void 0;let S=!1;switch(y.state){case e.ACTIVE:throw new Error(`${b}final state should never be 'ACTIVE'`);case e.NOMATCH:S=!1;break;case e.EMPTY:case e.MATCH:S=y.phraseLength===i.length;break;default:throw new Error("unrecognized state")}return{success:S,state:y.state,stateName:e.idName(y.state),length:i.length,matched:y.phraseLength,maxMatched:g,maxTreeDepth:d,nodeHits:f}};const w=(t,r,s,a)=>{if(r.phraseLength>s){let e=`${n}opRNM(${t.name}): callback function error: `;throw e+=`sysData.phraseLength: ${r.phraseLength}`,e+=` must be <= remaining chars: ${s}`,new Error(e)}switch(r.state){case e.ACTIVE:if(!a)throw new Error(`${n}opRNM(${t.name}): callback function return error. ACTIVE state not allowed.`);break;case e.EMPTY:r.phraseLength=0;break;case e.MATCH:0===r.phraseLength&&(r.state=e.EMPTY);break;case e.NOMATCH:r.phraseLength=0;break;default:throw new Error(`${n}opRNM(${t.name}): callback function return error. Unrecognized return state: ${r.state}`)}},x=(t,c)=>{let p,d,m;const T=o[t],f=a[T.index];y.UdtIndex=f.index,u||(m=r.ast&&r.ast.udtDefined(T.index),m&&(d=s.length+T.index,p=r.ast.getLength(),r.ast.down(d,f.name)));const g=i.length-c;h[T.index](y,i,c,l),((t,r,s)=>{if(r.phraseLength>s){let e=`${n}opUDT(${t.name}): callback function error: `;throw e+=`sysData.phraseLength: ${r.phraseLength}`,e+=` must be <= remaining chars: ${s}`,new Error(e)}switch(r.state){case e.ACTIVE:throw new Error(`${n}opUDT(${t.name}) ACTIVE state return not allowed.`);case e.EMPTY:if(!t.empty)throw new Error(`${n}opUDT(${t.name}) may not return EMPTY.`);r.phraseLength=0;break;case e.MATCH:if(0===r.phraseLength){if(!t.empty)throw new Error(`${n}opUDT(${t.name}) may not return EMPTY.`);r.state=e.EMPTY}break;case e.NOMATCH:r.phraseLength=0;break;default:throw new Error(`${n}opUDT(${t.name}): callback function return error. Unrecognized return state: ${r.state}`)}})(f,y,g),u||m&&(y.state===e.NOMATCH?r.ast.setLength(p):r.ast.up(d,f.name,c,y.phraseLength))},k=(t,a)=>{const h=`${n}opExecute(): `,m=o[t];switch(f+=1,p>d&&(d=p),p+=1,y.refresh(),r.trace&&r.trace.down(m,a),m.type){case e.ALT:((t,r)=>{const n=o[t];for(let t=0;t<n.children.length&&(k(n.children[t],r),y.state===e.NOMATCH);t+=1);})(t,a);break;case e.CAT:((t,n)=>{let s,a,i,c;const h=o[t];r.ast&&(a=r.ast.getLength()),s=!0,i=n,c=0;for(let t=0;t<h.children.length;t+=1){if(k(h.children[t],i),y.state===e.NOMATCH){s=!1;break}i+=y.phraseLength,c+=y.phraseLength}s?(y.state=0===c?e.EMPTY:e.MATCH,y.phraseLength=c):(y.state=e.NOMATCH,y.phraseLength=0,r.ast&&r.ast.setLength(a))})(t,a);break;case e.REP:((t,n)=>{let s,a,c,h;const l=o[t];if(0===l.max)return y.state=e.EMPTY,void(y.phraseLength=0);for(a=n,c=0,h=0,r.ast&&(s=r.ast.getLength());!(a>=i.length)&&(k(t+1,a),y.state!==e.NOMATCH)&&y.state!==e.EMPTY&&(h+=1,c+=y.phraseLength,a+=y.phraseLength,h!==l.max););y.state===e.EMPTY||h>=l.min?(y.state=0===c?e.EMPTY:e.MATCH,y.phraseLength=c):(y.state=e.NOMATCH,y.phraseLength=0,r.ast&&r.ast.setLength(s))})(t,a);break;case e.RNM:((t,n)=>{let a,h,p;const d=o[t],m=s[d.index],T=c[m.index];if(u||(h=r.ast&&r.ast.ruleDefined(d.index),h&&(a=r.ast.getLength(),r.ast.down(d.index,s[d.index].name))),T){const t=i.length-n;T(y,i,n,l),w(m,y,t,!0),y.state===e.ACTIVE&&(p=o,o=m.opcodes,k(0,n),o=p,T(y,i,n,l),w(m,y,t,!1))}else p=o,o=m.opcodes,k(0,n,y),o=p;u||h&&(y.state===e.NOMATCH?r.ast.setLength(a):r.ast.up(d.index,m.name,n,y.phraseLength))})(t,a);break;case e.TRG:((t,r)=>{const n=o[t];y.state=e.NOMATCH,r<i.length&&n.min<=i[r]&&i[r]<=n.max&&(y.state=e.MATCH,y.phraseLength=1)})(t,a);break;case e.TBS:((t,r)=>{const n=o[t],s=n.string.length;if(y.state=e.NOMATCH,r+s<=i.length){for(let e=0;e<s;e+=1)if(i[r+e]!==n.string[e])return;y.state=e.MATCH,y.phraseLength=s}})(t,a);break;case e.TLS:((t,r)=>{let n;const s=o[t];y.state=e.NOMATCH;const a=s.string.length;if(0!==a){if(r+a<=i.length){for(let e=0;e<a;e+=1)if(n=i[r+e],n>=65&&n<=90&&(n+=32),n!==s.string[e])return;y.state=e.MATCH,y.phraseLength=a}}else y.state=e.EMPTY})(t,a);break;case e.UDT:x(t,a);break;case e.AND:((t,r)=>{switch(u+=1,k(t+1,r),u-=1,y.phraseLength=0,y.state){case e.EMPTY:case e.MATCH:y.state=e.EMPTY;break;case e.NOMATCH:y.state=e.NOMATCH;break;default:throw new Error(`opAND: invalid state ${y.state}`)}})(t,a);break;case e.NOT:((t,r)=>{switch(u+=1,k(t+1,r),u-=1,y.phraseLength=0,y.state){case e.EMPTY:case e.MATCH:y.state=e.NOMATCH;break;case e.NOMATCH:y.state=e.EMPTY;break;default:throw new Error(`opNOT: invalid state ${y.state}`)}})(t,a);break;default:throw new Error(`${h}unrecognized operator`)}u||a+y.phraseLength>g&&(g=a+y.phraseLength),r.stats&&r.stats.collect(m,y),r.trace&&r.trace.up(m,y.state,a,y.phraseLength),p-=1}},u=function(){const e=T,t=m,r=this;let n,s,a,o=0;const i=[],c=[],h=[];function l(e){let t="";for(;e-- >0;)t+=" ";return t}r.callbacks=[],r.init=(e,t,l)=>{let u;c.length=0,h.length=0,o=0,n=e,s=t,a=l;const p=[];for(u=0;u<n.length;u+=1)p.push(n[u].lower);for(u=0;u<s.length;u+=1)p.push(s[u].lower);for(o=n.length+s.length,u=0;u<o;u+=1)i[u]=void 0;for(const e in r.callbacks)if(r.callbacks.hasOwnProperty(e)){const t=e.toLowerCase();if(u=p.indexOf(t),u<0)throw new Error(`parser.js: Ast()): init: node '${e}' not a rule or udt name`);i[u]=r.callbacks[e]}},r.ruleDefined=e=>!!i[e],r.udtDefined=e=>!!i[n.length+e],r.down=(t,r)=>{const n=h.length;return c.push(n),h.push({name:r,thisIndex:n,thatIndex:void 0,state:e.SEM_PRE,callbackIndex:t,phraseIndex:void 0,phraseLength:void 0,stack:c.length}),n},r.up=(t,r,n,s)=>{const a=h.length,o=c.pop();return h.push({name:r,thisIndex:a,thatIndex:o,state:e.SEM_POST,callbackIndex:t,phraseIndex:n,phraseLength:s,stack:c.length}),h[o].thatIndex=a,h[o].phraseIndex=n,h[o].phraseLength=s,a},r.translate=t=>{let r,n;for(let s=0;s<h.length;s+=1)n=h[s],r=i[n.callbackIndex],r&&(n.state===e.SEM_PRE?r(e.SEM_PRE,a,n.phraseIndex,n.phraseLength,t):r&&r(e.SEM_POST,a,n.phraseIndex,n.phraseLength,t))},r.setLength=e=>{h.length=e,c.length=e>0?h[e-1].stack:0},r.getLength=()=>h.length,r.toXml=()=>{let r="",n=0;return r+='<?xml version="1.0" encoding="utf-8"?>\n',r+=`<root nodes="${h.length/2}" characters="${a.length}">\n`,r+="\x3c!-- input string --\x3e\n",r+=l(n+2),r+=t.charsToString(a),r+="\n",h.forEach((s=>{s.state===e.SEM_PRE?(n+=1,r+=l(n),r+=`<node name="${s.name}" index="${s.phraseIndex}" length="${s.phraseLength}">\n`,r+=l(n+2),r+=t.charsToString(a,s.phraseIndex,s.phraseLength),r+="\n"):(r+=l(n),r+=`</node>\x3c!-- name="${s.name}" --\x3e\n`,n-=1)})),r+="</root>\n",r}},p=function(){const e=T,t=m,r="parser.js: Trace(): ";let n,s,a,o="",i=0;const c=this,h=e=>{let t="",r=0;if(e>=0)for(;e--;)r+=1,5===r?(t+="|",r=0):t+=".";return t};c.init=(e,t,r)=>{s=e,a=t,n=r};const l=n=>{let o;switch(n.type){case e.ALT:o="ALT";break;case e.CAT:o="CAT";break;case e.REP:o=n.max===1/0?`REP(${n.min},inf)`:`REP(${n.min},${n.max})`;break;case e.RNM:o=`RNM(${s[n.index].name})`;break;case e.TRG:o=`TRG(${n.min},${n.max})`;break;case e.TBS:o=n.string.length>6?`TBS(${t.charsToString(n.string,0,3)}...)`:`TBS(${t.charsToString(n.string,0,6)})`;break;case e.TLS:o=n.string.length>6?`TLS(${t.charsToString(n.string,0,3)}...)`:`TLS(${t.charsToString(n.string,0,6)})`;break;case e.UDT:o=`UDT(${a[n.index].name})`;break;case e.AND:o="AND";break;case e.NOT:o="NOT";break;default:throw new Error(`${r}Trace: opName: unrecognized opcode`)}return o};c.down=(e,r)=>{const s=h(i),a=Math.min(100,n.length-r);let c=t.charsToString(n,r,a);a<n.length-r&&(c+="..."),c=`${s}|-|[${l(e)}]${c}\n`,o+=c,i+=1},c.up=(s,a,c,u)=>{const p=`${r}trace.up: `;i-=1;const d=h(i);let m,T,f;switch(a){case e.EMPTY:f="|E|",T="''";break;case e.MATCH:f="|M|",m=Math.min(100,u),T=m<u?`'${t.charsToString(n,c,m)}...'`:`'${t.charsToString(n,c,m)}'`;break;case e.NOMATCH:f="|N|",T="";break;default:throw new Error(`${p} unrecognized state`)}T=`${d}${f}[${l(s)}]${T}\n`,o+=T},c.displayTrace=()=>o},d=function(){const e=T;let t,r,n;const s=[],a=[],o=[];this.init=(e,n)=>{t=e,r=n,p()},this.collect=(t,r)=>{d(n,r.state,r.phraseLength),d(s[t.type],r.state,r.phraseLength),t.type===e.RNM&&d(a[t.index],r.state,r.phraseLength),t.type===e.UDT&&d(o[t.index],r.state,r.phraseLength)},this.displayStats=()=>{let t="";const r={match:0,empty:0,nomatch:0,total:0},n=(e,t,n,s,a)=>{r.match+=t,r.empty+=n,r.nomatch+=s,r.total+=a;return`${e} | ${i(t)} | ${i(n)} | ${i(s)} | ${i(a)} |\n`};return t+="          OPERATOR STATS\n",t+="      |   MATCH |   EMPTY | NOMATCH |   TOTAL |\n",t+=n("  ALT",s[e.ALT].match,s[e.ALT].empty,s[e.ALT].nomatch,s[e.ALT].total),t+=n("  CAT",s[e.CAT].match,s[e.CAT].empty,s[e.CAT].nomatch,s[e.CAT].total),t+=n("  REP",s[e.REP].match,s[e.REP].empty,s[e.REP].nomatch,s[e.REP].total),t+=n("  RNM",s[e.RNM].match,s[e.RNM].empty,s[e.RNM].nomatch,s[e.RNM].total),t+=n("  TRG",s[e.TRG].match,s[e.TRG].empty,s[e.TRG].nomatch,s[e.TRG].total),t+=n("  TBS",s[e.TBS].match,s[e.TBS].empty,s[e.TBS].nomatch,s[e.TBS].total),t+=n("  TLS",s[e.TLS].match,s[e.TLS].empty,s[e.TLS].nomatch,s[e.TLS].total),t+=n("  UDT",s[e.UDT].match,s[e.UDT].empty,s[e.UDT].nomatch,s[e.UDT].total),t+=n("  AND",s[e.AND].match,s[e.AND].empty,s[e.AND].nomatch,s[e.AND].total),t+=n("  NOT",s[e.NOT].match,s[e.NOT].empty,s[e.NOT].nomatch,s[e.NOT].total),t+=n("TOTAL",r.match,r.empty,r.nomatch,r.total),t},this.displayHits=e=>{let t="";const r=(e,t,r,s,a)=>{n.match+=e,n.empty+=t,n.nomatch+=r,n.total+=s;return`| ${i(e)} | ${i(t)} | ${i(r)} | ${i(s)} | ${a}\n`};"string"==typeof e&&"a"===e.toLowerCase()[0]?(a.sort(c),o.sort(c),t+="    RULES/UDTS ALPHABETICALLY\n"):"string"==typeof e&&"i"===e.toLowerCase()[0]?(a.sort(l),o.sort(l),t+="    RULES/UDTS BY INDEX\n"):(a.sort(h),o.sort(h),t+="    RULES/UDTS BY HIT COUNT\n"),t+="|   MATCH |   EMPTY | NOMATCH |   TOTAL | NAME\n";for(let e=0;e<a.length;e+=1){let n=a[e];n.total&&(t+=r(n.match,n.empty,n.nomatch,n.total,n.name))}for(let e=0;e<o.length;e+=1){let n=o[e];n.total&&(t+=r(n.match,n.empty,n.nomatch,n.total,n.name))}return t};const i=e=>e<10?`      ${e}`:e<100?`     ${e}`:e<1e3?`    ${e}`:e<1e4?`   ${e}`:e<1e5?`  ${e}`:e<1e6?` ${e}`:`${e}`,c=(e,t)=>e.lower<t.lower?-1:e.lower>t.lower?1:0,h=(e,t)=>e.total<t.total?1:e.total>t.total?-1:c(e,t),l=(e,t)=>e.index<t.index?-1:e.index>t.index?1:0,u=function(){this.empty=0,this.match=0,this.nomatch=0,this.total=0},p=()=>{s.length=0,n=new u,s[e.ALT]=new u,s[e.CAT]=new u,s[e.REP]=new u,s[e.RNM]=new u,s[e.TRG]=new u,s[e.TBS]=new u,s[e.TLS]=new u,s[e.UDT]=new u,s[e.AND]=new u,s[e.NOT]=new u,a.length=0;for(let e=0;e<t.length;e+=1)a.push({empty:0,match:0,nomatch:0,total:0,name:t[e].name,lower:t[e].lower,index:t[e].index});if(r.length>0){o.length=0;for(let e=0;e<r.length;e+=1)o.push({empty:0,match:0,nomatch:0,total:0,name:r[e].name,lower:r[e].lower,index:r[e].index})}},d=(t,r)=>{switch(t.total+=1,r){case e.EMPTY:t.empty+=1;break;case e.MATCH:t.match+=1;break;case e.NOMATCH:t.nomatch+=1;break;default:throw new Error(`parser.js: Stats(): collect(): incStat(): unrecognized state: ${r}`)}}},m={stringToChars:e=>[...e].map((e=>e.codePointAt(0))),charsToString:(e,t,r)=>{let n=e;for(;!(void 0===t||t<0);){if(void 0===r){n=e.slice(t);break}if(r<=0)return"";n=e.slice(t,t+r);break}return String.fromCodePoint(...n)}},T={ALT:1,CAT:2,REP:3,RNM:4,TRG:5,TBS:6,TLS:7,UDT:11,AND:12,NOT:13,ACTIVE:100,MATCH:101,EMPTY:102,NOMATCH:103,SEM_PRE:200,SEM_POST:201,SEM_OK:300,idName:e=>{switch(e){case T.ALT:return"ALT";case T.CAT:return"CAT";case T.REP:return"REP";case T.RNM:return"RNM";case T.TRG:return"TRG";case T.TBS:return"TBS";case T.TLS:return"TLS";case T.UDT:return"UDT";case T.AND:return"AND";case T.NOT:return"NOT";case T.ACTIVE:return"ACTIVE";case T.EMPTY:return"EMPTY";case T.MATCH:return"MATCH";case T.NOMATCH:return"NOMATCH";case T.SEM_PRE:return"SEM_PRE";case T.SEM_POST:return"SEM_POST";case T.SEM_OK:return"SEM_OK";default:return"UNRECOGNIZED STATE"}}};class f extends Error{constructor(e,t=void 0){if(super(e,t),this.name=this.constructor.name,"string"==typeof e&&(this.message=e),"function"==typeof Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error(e).stack,null!=t&&"object"==typeof t&&Object.prototype.hasOwnProperty.call(t,"cause")&&!("cause"in this)){const{cause:e}=t;this.cause=e,e instanceof Error&&"stack"in e&&(this.stack=`${this.stack}\nCAUSE: ${e.stack}`)}if(null!=t&&"object"==typeof t){const{cause:e,...r}=t;Object.assign(this,r)}}}const g=f;const y=class extends g{},w=e=>(t,r,n,s,a)=>{if("object"!=typeof a||null===a||Array.isArray(a))throw new y("parser's user data must be an object");if(t===T.SEM_PRE){const t={type:e,text:m.charsToString(r,n,s),start:n,length:s,children:[]};if(a.stack.length>0){a.stack[a.stack.length-1].children.push(t)}else a.root=t;a.stack.push(t)}t===T.SEM_POST&&a.stack.pop()};const x=class extends u{constructor(){super(),this.callbacks["json-pointer"]=w("json-pointer"),this.callbacks["reference-token"]=w("reference-token"),this.callbacks.slash=w("text")}getTree(){const e={stack:[],root:null};return this.translate(e),delete e.stack,e}},k=e=>{if("string"!=typeof e)throw new TypeError("Reference token must be a string");return e.replace(/~1/g,"/").replace(/~0/g,"~")};const b=class extends x{getTree(){const{root:e}=super.getTree();return e.children.filter((({type:e})=>"reference-token"===e)).map((({text:e})=>k(e)))}};const A=class extends Array{toString(){return this.map((e=>`"${String(e)}"`)).join(", ")}};const E=class extends p{inferExpectations(){const e=this.displayTrace().split("\n"),t=new Set;let r=-1;for(let n=0;n<e.length;n++){const s=e[n];if(s.includes("M|")){const e=s.match(/]'(.*)'$/);e&&e[1]&&(r=n)}if(n>r){const e=s.match(/N\|\[TLS\(([^)]+)\)]/);e&&t.add(e[1])}}return new A(...t)}},S=new h,O=(e,{translator:t=new b,stats:r=!1,trace:n=!1}={})=>{if("string"!=typeof e)throw new TypeError("JSON Pointer must be a string");try{const s=new l;t&&(s.ast=t),r&&(s.stats=new d),n&&(s.trace=new E);const a=s.parse(S,"json-pointer",e);return{result:a,tree:a.success&&t?s.ast.getTree():void 0,stats:s.stats,trace:s.trace}}catch(t){throw new y("Unexpected error during JSON Pointer parsing",{cause:t,jsonPointer:e})}};const $=class extends x{getTree(){return this.toXml()}},M=e=>{try{return O(e,{translator:null}).result.success}catch{return!1}},N=new h,P=new l,L=e=>{if("string"!=typeof e)return!1;try{return P.parse(N,"reference-token",e).success}catch{return!1}},C=new h,R=new l,v=e=>{if("string"!=typeof e)return!1;try{return R.parse(C,"array-location",e).success}catch{return!1}},j=new h,I=new l,D=e=>{if("string"!=typeof e)return!1;try{return I.parse(j,"array-index",e).success}catch{return!1}},H=new h,U=new l,Y=e=>{if("string"!=typeof e)return!1;try{return U.parse(H,"array-dash",e).success}catch{return!1}},B=e=>{if("string"!=typeof e&&"number"!=typeof e)throw new TypeError("Reference token must be a string or number");return String(e).replace(/~/g,"~0").replace(/\//g,"~1")};const J=class extends g{},V=e=>{if(!Array.isArray(e))throw new TypeError("Reference tokens must be a list of strings or numbers");try{return 0===e.length?"":`/${e.map((e=>{if("string"!=typeof e&&"number"!=typeof e)throw new TypeError("Reference token must be a string or number");return B(String(e))})).join("/")}`}catch(t){throw new J("Unexpected error during JSON Pointer compilation",{cause:t,referenceTokens:e})}};const _=class{#e;#t;#r;constructor(e,t={}){this.#e=e,this.#e.steps=[],this.#e.failed=!1,this.#e.failedAt=-1,this.#e.message=`JSON Pointer "${t.jsonPointer}" was successfully evaluated against the provided value`,this.#e.context={...t,realm:t.realm.name},this.#t=[],this.#r=t.realm}step({referenceToken:e,input:t,output:r,success:n=!0,reason:s}){const a=this.#t.length;this.#t.push(e);const o={referenceToken:e,referenceTokenPosition:a,input:t,inputType:this.#r.isObject(t)?"object":this.#r.isArray(t)?"array":"unrecognized",output:r,success:n};s&&(o.reason=s),this.#e.steps.push(o),n||(this.#e.failed=!0,this.#e.failedAt=a,this.#e.message=s)}};const z=class{name="";isArray(e){throw new g("Realm.isArray(node) must be implemented in a subclass")}isObject(e){throw new g("Realm.isObject(node) must be implemented in a subclass")}sizeOf(e){throw new g("Realm.sizeOf(node) must be implemented in a subclass")}has(e,t){throw new g("Realm.has(node) must be implemented in a subclass")}evaluate(e,t){throw new g("Realm.evaluate(node) must be implemented in a subclass")}};const F=class extends g{};const G=class extends F{};const K=class extends z{name="json";isArray(e){return Array.isArray(e)}isObject(e){return"object"==typeof e&&null!==e&&!this.isArray(e)}sizeOf(e){return this.isArray(e)?e.length:this.isObject(e)?Object.keys(e).length:0}has(e,t){if(this.isArray(e)){const r=Number(t),n=r>>>0;if(r!==n)throw new G(`Invalid array index "${t}": index must be an unsinged 32-bit integer`,{referenceToken:t,currentValue:e,realm:this.name});return n<this.sizeOf(e)&&Object.prototype.hasOwnProperty.call(e,r)}return!!this.isObject(e)&&Object.prototype.hasOwnProperty.call(e,t)}evaluate(e,t){return this.isArray(e)?e[Number(t)]:e[t]}};const X=class extends F{};const Z=class extends F{},W=(e,t,{strictArrays:r=!0,strictObjects:n=!0,realm:s=new K,trace:a=!0}={})=>{const{result:o,tree:i,trace:c}=O(t,{trace:!!a}),h="object"==typeof a&&null!==a?new _(a,{jsonPointer:t,referenceTokens:i,strictArrays:r,strictObjects:n,realm:s,value:e}):null;try{let a;if(!o.success){let r=`Invalid JSON Pointer: "${t}". Syntax error at position ${o.maxMatched}`;throw r+=c?`, expected ${c.inferExpectations()}`:"",new F(r,{jsonPointer:t,currentValue:e,realm:s.name})}return i.reduce(((e,o,c)=>{if(s.isArray(e)){if(Y(o)){if(r)throw new G(`Invalid array index "-" at position ${c} in "${t}". The "-" token always refers to a nonexistent element during evaluation`,{jsonPointer:t,referenceTokens:i,referenceToken:o,referenceTokenPosition:c,currentValue:e,realm:s.name});return a=s.evaluate(e,String(s.sizeOf(e))),h?.step({referenceToken:o,input:e,output:a}),a}if(!D(o))throw new G(`Invalid array index "${o}" at position ${c} in "${t}": index MUST be "0", or digits without a leading "0"`,{jsonPointer:t,referenceTokens:i,referenceToken:o,referenceTokenPosition:c,currentValue:e,realm:s.name});const n=Number(o);if(!Number.isSafeInteger(n))throw new G(`Invalid array index "${o}" at position ${c} in "${t}": index must be a safe integer`,{jsonPointer:t,referenceTokens:i,referenceToken:o,referenceTokenPosition:c,currentValue:e,realm:s.name});if(!s.has(e,o)&&r)throw new G(`Invalid array index "${o}" at position ${c} in "${t}": index not found in array`,{jsonPointer:t,referenceTokens:i,referenceToken:o,referenceTokenPosition:c,currentValue:e,realm:s.name});return a=s.evaluate(e,o),h?.step({referenceToken:o,input:e,output:a}),a}if(s.isObject(e)){if(!s.has(e,o)&&n)throw new Z(`Invalid object key "${o}" at position ${c} in "${t}": key not found in object`,{jsonPointer:t,referenceTokens:i,referenceToken:o,referenceTokenPosition:c,currentValue:e,realm:s.name});return a=s.evaluate(e,o),h?.step({referenceToken:o,input:e,output:a}),a}throw new X(`Invalid reference token "${o}" at position ${c} in "${t}": cannot be applied to a non-object/non-array value`,{jsonPointer:t,referenceTokens:i,referenceToken:o,referenceTokenPosition:c,currentValue:e,realm:s.name})}),e)}catch(e){if(h?.step({referenceToken:e.referenceToken,input:e.currentValue,success:!1,reason:e.message}),e instanceof F)throw e;throw new F("Unexpected error during JSON Pointer evaluation",{cause:e,jsonPointer:t,referenceTokens:i})}};class q extends z{name="composite";realms=[];constructor(e){super(),this.realms=e}isArray(e){return this.#n(e).isArray(e)}isObject(e){return this.#n(e).isObject(e)}sizeOf(e){return this.#n(e).sizeOf(e)}has(e,t){return this.#n(e).has(e,t)}evaluate(e,t){return this.#n(e).evaluate(e,t)}#n(e){for(const t of this.realms)if(t.isArray(e)||t.isObject(e))return t;throw new F("No suitable evaluation realm found for value",{currentValue:e})}}const Q=(...e)=>new q(e);return t})()));